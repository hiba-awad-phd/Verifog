/*
 * generated by Xtext 2.28.0
 */
package fr.imta.semafor.serializer;

import com.google.inject.Inject;
import fr.imta.semafor.fogAdlModel.Application;
import fr.imta.semafor.fogAdlModel.Attribute;
import fr.imta.semafor.fogAdlModel.AttributeExpression;
import fr.imta.semafor.fogAdlModel.AttributeType;
import fr.imta.semafor.fogAdlModel.ConnectorType;
import fr.imta.semafor.fogAdlModel.Constraint;
import fr.imta.semafor.fogAdlModel.CustomExpression;
import fr.imta.semafor.fogAdlModel.FogAdlModelPackage;
import fr.imta.semafor.fogAdlModel.FogArea;
import fr.imta.semafor.fogAdlModel.FogSystem;
import fr.imta.semafor.fogAdlModel.IntegerValueExpression;
import fr.imta.semafor.fogAdlModel.MultiplicityExpression;
import fr.imta.semafor.fogAdlModel.NetworkClassExpression;
import fr.imta.semafor.fogAdlModel.NetworkLinkType;
import fr.imta.semafor.fogAdlModel.NetworkPort;
import fr.imta.semafor.fogAdlModel.NetworkType;
import fr.imta.semafor.fogAdlModel.PhysicalNode;
import fr.imta.semafor.fogAdlModel.PhysicalNodeSpecification;
import fr.imta.semafor.fogAdlModel.ServiceType;
import fr.imta.semafor.fogAdlModel.SoftwarePackage;
import fr.imta.semafor.fogAdlModel.Tag;
import fr.imta.semafor.fogAdlModel.VirtualNode;
import fr.imta.semafor.fogAdlModel.VirtualNodeSpecification;
import fr.imta.semafor.services.FogDslGrammarAccess;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class FogDslSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private FogDslGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == FogAdlModelPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case FogAdlModelPackage.APPLICATION:
				sequence_Application(context, (Application) semanticObject); 
				return; 
			case FogAdlModelPackage.ATTRIBUTE:
				sequence_AttributeValueUnit(context, (Attribute) semanticObject); 
				return; 
			case FogAdlModelPackage.ATTRIBUTE_EXPRESSION:
				if (rule == grammarAccess.getAttributeExpressionRule()) {
					sequence_AttributeExpression(context, (AttributeExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getCpuAttributeExpressionRule()) {
					sequence_CpuAttributeExpression(context, (AttributeExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getDiskAttributeExpressionRule()) {
					sequence_DiskAttributeExpression(context, (AttributeExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getMemoryAttributeExpressionRule()) {
					sequence_MemoryAttributeExpression(context, (AttributeExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getNetworkClassExpressionRule()) {
					sequence_NetworkClassExpression(context, (AttributeExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getReplicasAttributeExpressionRule()) {
					sequence_ReplicasAttributeExpression(context, (AttributeExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getRuntimesAttributeExpressionRule()) {
					sequence_RuntimesAttributeExpression(context, (AttributeExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getBandwidthExpressionRule()) {
					sequence_bandwidthExpression(context, (AttributeExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getIpRangeExpressionRule()) {
					sequence_ipRangeExpression(context, (AttributeExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getPortsExpressionRule()) {
					sequence_portsExpression(context, (AttributeExpression) semanticObject); 
					return; 
				}
				else break;
			case FogAdlModelPackage.ATTRIBUTE_TYPE:
				sequence_AttributeType(context, (AttributeType) semanticObject); 
				return; 
			case FogAdlModelPackage.CONNECTOR_TYPE:
				sequence_ConnectorType(context, (ConnectorType) semanticObject); 
				return; 
			case FogAdlModelPackage.CONSTRAINT:
				if (rule == grammarAccess.getBandwidthConstraintRule()) {
					sequence_BandwidthConstraint(context, (Constraint) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getConstraintRule()) {
					sequence_Constraint(context, (Constraint) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getCpuConstraintRule()) {
					sequence_CpuConstraint(context, (Constraint) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getMemoryConsraintRule()) {
					sequence_MemoryConsraint(context, (Constraint) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getPortsConstraintRule()) {
					sequence_PortsConstraint(context, (Constraint) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getReplicasConstraintRule()) {
					sequence_ReplicasConstraint(context, (Constraint) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getRuntimesConstraintRule()) {
					sequence_RuntimesConstraint(context, (Constraint) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getDiskConstraintRule()) {
					sequence_diskConstraint(context, (Constraint) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getIpRangeConstraintRule()) {
					sequence_ipRangeConstraint(context, (Constraint) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getNetworkClassConstraintRule()) {
					sequence_networkClassConstraint(context, (Constraint) semanticObject); 
					return; 
				}
				else break;
			case FogAdlModelPackage.CUSTOM_EXPRESSION:
				if (rule == grammarAccess.getCustomExpressionRule()) {
					sequence_CustomExpression(context, (CustomExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getRangeExpressionRule()) {
					sequence_rangeExpression(context, (CustomExpression) semanticObject); 
					return; 
				}
				else break;
			case FogAdlModelPackage.FOG_AREA:
				sequence_fogArea(context, (FogArea) semanticObject); 
				return; 
			case FogAdlModelPackage.FOG_SYSTEM:
				sequence_fogSystem(context, (FogSystem) semanticObject); 
				return; 
			case FogAdlModelPackage.INTEGER_VALUE_EXPRESSION:
				sequence_IntegerValueExpression(context, (IntegerValueExpression) semanticObject); 
				return; 
			case FogAdlModelPackage.MULTIPLICITY_EXPRESSION:
				sequence_MultiplicityExpression(context, (MultiplicityExpression) semanticObject); 
				return; 
			case FogAdlModelPackage.NETWORK_CLASS_EXPRESSION:
				sequence_NetworkClassEnumExpression(context, (NetworkClassExpression) semanticObject); 
				return; 
			case FogAdlModelPackage.NETWORK_LINK_TYPE:
				sequence_NetworkLinksType(context, (NetworkLinkType) semanticObject); 
				return; 
			case FogAdlModelPackage.NETWORK_PORT:
				sequence_NetworkPort(context, (NetworkPort) semanticObject); 
				return; 
			case FogAdlModelPackage.NETWORK_TYPE:
				sequence_NetworkType(context, (NetworkType) semanticObject); 
				return; 
			case FogAdlModelPackage.PHYSICAL_NODE:
				sequence_PhysicalNode(context, (PhysicalNode) semanticObject); 
				return; 
			case FogAdlModelPackage.PHYSICAL_NODE_SPECIFICATION:
				sequence_PhysicalNodeType(context, (PhysicalNodeSpecification) semanticObject); 
				return; 
			case FogAdlModelPackage.SERVICE_TYPE:
				sequence_SerivceType(context, (ServiceType) semanticObject); 
				return; 
			case FogAdlModelPackage.SOFTWARE_PACKAGE:
				sequence_SoftwarePackage(context, (SoftwarePackage) semanticObject); 
				return; 
			case FogAdlModelPackage.TAG:
				sequence_Tag(context, (Tag) semanticObject); 
				return; 
			case FogAdlModelPackage.VIRTUAL_NODE:
				sequence_VirtualNode(context, (VirtualNode) semanticObject); 
				return; 
			case FogAdlModelPackage.VIRTUAL_NODE_SPECIFICATION:
				sequence_VirtualNodeType(context, (VirtualNodeSpecification) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     FogResource returns Application
	 *     Application returns Application
	 *
	 * Constraint:
	 *     (name=ID? tags+=Tag* serviceTypes+=SerivceType* connectortypes+=ConnectorType*)
	 * </pre>
	 */
	protected void sequence_Application(ISerializationContext context, Application semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AttributeExpression returns AttributeExpression
	 *
	 * Constraint:
	 *     attributeName=EString
	 * </pre>
	 */
	protected void sequence_AttributeExpression(ISerializationContext context, AttributeExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FogAdlModelPackage.Literals.ATTRIBUTE_EXPRESSION__ATTRIBUTE_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FogAdlModelPackage.Literals.ATTRIBUTE_EXPRESSION__ATTRIBUTE_NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAttributeExpressionAccess().getAttributeNameEStringParserRuleCall_0(), semanticObject.getAttributeName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FogResource returns AttributeType
	 *     AttributeType returns AttributeType
	 *
	 * Constraint:
	 *     (name=EString valueType=EString unitofmeasurment+=[UnitOfMeasurment|ID]*)
	 * </pre>
	 */
	protected void sequence_AttributeType(ISerializationContext context, AttributeType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AttributeValueUnit returns Attribute
	 *
	 * Constraint:
	 *     (instanceOf=[AttributeType|ID] value=Value)
	 * </pre>
	 */
	protected void sequence_AttributeValueUnit(ISerializationContext context, Attribute semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FogAdlModelPackage.Literals.ATTRIBUTE__INSTANCE_OF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FogAdlModelPackage.Literals.ATTRIBUTE__INSTANCE_OF));
			if (transientValues.isValueTransient(semanticObject, FogAdlModelPackage.Literals.ATTRIBUTE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FogAdlModelPackage.Literals.ATTRIBUTE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAttributeValueUnitAccess().getInstanceOfAttributeTypeIDTerminalRuleCall_0_0_1(), semanticObject.eGet(FogAdlModelPackage.Literals.ATTRIBUTE__INSTANCE_OF, false));
		feeder.accept(grammarAccess.getAttributeValueUnitAccess().getValueValueParserRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     BandwidthConstraint returns Constraint
	 *
	 * Constraint:
	 *     ((expression+=bandwidthExpression expression+=IntegerValueExpression) | (operator=ComparaisonOperator expression+=IntegerValueExpression))
	 * </pre>
	 */
	protected void sequence_BandwidthConstraint(ISerializationContext context, Constraint semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ConnectorType returns ConnectorType
	 *
	 * Constraint:
	 *     (name=ID sourceServices+=[ServiceType|ID]* targetServices+=[ServiceType|ID]* constraints+=Constraint*)
	 * </pre>
	 */
	protected void sequence_ConnectorType(ISerializationContext context, ConnectorType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Constraint returns Constraint
	 *
	 * Constraint:
	 *     (
	 *         expression+=AttributeExpression 
	 *         (
	 *             expression+=IntegerValueExpression | 
	 *             expression+=AttributeExpression | 
	 *             (operator=ComparaisonOperator (expression+=IntegerValueExpression | expression+=AttributeExpression))
	 *         )
	 *     )
	 * </pre>
	 */
	protected void sequence_Constraint(ISerializationContext context, Constraint semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     CpuAttributeExpression returns AttributeExpression
	 *
	 * Constraint:
	 *     attributeName='CpuCores'
	 * </pre>
	 */
	protected void sequence_CpuAttributeExpression(ISerializationContext context, AttributeExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FogAdlModelPackage.Literals.ATTRIBUTE_EXPRESSION__ATTRIBUTE_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FogAdlModelPackage.Literals.ATTRIBUTE_EXPRESSION__ATTRIBUTE_NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCpuAttributeExpressionAccess().getAttributeNameCpuCoresKeyword_0(), semanticObject.getAttributeName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     CpuConstraint returns Constraint
	 *
	 * Constraint:
	 *     (expression+=CpuAttributeExpression (expression+=IntegerValueExpression | (operator=ComparaisonOperator expression+=IntegerValueExpression)))
	 * </pre>
	 */
	protected void sequence_CpuConstraint(ISerializationContext context, Constraint semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     CustomExpression returns CustomExpression
	 *
	 * Constraint:
	 *     expression=STRING
	 * </pre>
	 */
	protected void sequence_CustomExpression(ISerializationContext context, CustomExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FogAdlModelPackage.Literals.CUSTOM_EXPRESSION__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FogAdlModelPackage.Literals.CUSTOM_EXPRESSION__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCustomExpressionAccess().getExpressionSTRINGTerminalRuleCall_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     DiskAttributeExpression returns AttributeExpression
	 *
	 * Constraint:
	 *     attributeName='diskStorage'
	 * </pre>
	 */
	protected void sequence_DiskAttributeExpression(ISerializationContext context, AttributeExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FogAdlModelPackage.Literals.ATTRIBUTE_EXPRESSION__ATTRIBUTE_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FogAdlModelPackage.Literals.ATTRIBUTE_EXPRESSION__ATTRIBUTE_NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDiskAttributeExpressionAccess().getAttributeNameDiskStorageKeyword_0(), semanticObject.getAttributeName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     IntegerValueExpression returns IntegerValueExpression
	 *
	 * Constraint:
	 *     value=INT
	 * </pre>
	 */
	protected void sequence_IntegerValueExpression(ISerializationContext context, IntegerValueExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FogAdlModelPackage.Literals.INTEGER_VALUE_EXPRESSION__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FogAdlModelPackage.Literals.INTEGER_VALUE_EXPRESSION__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIntegerValueExpressionAccess().getValueINTTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     MemoryAttributeExpression returns AttributeExpression
	 *
	 * Constraint:
	 *     attributeName='memory'
	 * </pre>
	 */
	protected void sequence_MemoryAttributeExpression(ISerializationContext context, AttributeExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FogAdlModelPackage.Literals.ATTRIBUTE_EXPRESSION__ATTRIBUTE_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FogAdlModelPackage.Literals.ATTRIBUTE_EXPRESSION__ATTRIBUTE_NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMemoryAttributeExpressionAccess().getAttributeNameMemoryKeyword_0(), semanticObject.getAttributeName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     MemoryConsraint returns Constraint
	 *
	 * Constraint:
	 *     (
	 *         expression+=MemoryAttributeExpression 
	 *         (expression+=IntegerValueExpression | (operator=ComparaisonOperator expression+=IntegerValueExpression))
	 *     )
	 * </pre>
	 */
	protected void sequence_MemoryConsraint(ISerializationContext context, Constraint semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     MultiplicityExpression returns MultiplicityExpression
	 *
	 * Constraint:
	 *     multiplicityOperator=MultiplicityOperator
	 * </pre>
	 */
	protected void sequence_MultiplicityExpression(ISerializationContext context, MultiplicityExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FogAdlModelPackage.Literals.MULTIPLICITY_EXPRESSION__MULTIPLICITY_OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FogAdlModelPackage.Literals.MULTIPLICITY_EXPRESSION__MULTIPLICITY_OPERATOR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMultiplicityExpressionAccess().getMultiplicityOperatorMultiplicityOperatorEnumRuleCall_0(), semanticObject.getMultiplicityOperator());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     NetworkClassEnumExpression returns NetworkClassExpression
	 *
	 * Constraint:
	 *     value=NetworkClassEnum
	 * </pre>
	 */
	protected void sequence_NetworkClassEnumExpression(ISerializationContext context, NetworkClassExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FogAdlModelPackage.Literals.NETWORK_CLASS_EXPRESSION__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FogAdlModelPackage.Literals.NETWORK_CLASS_EXPRESSION__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNetworkClassEnumExpressionAccess().getValueNetworkClassEnumEnumRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     NetworkClassExpression returns AttributeExpression
	 *
	 * Constraint:
	 *     attributeName='networkClass'
	 * </pre>
	 */
	protected void sequence_NetworkClassExpression(ISerializationContext context, AttributeExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FogAdlModelPackage.Literals.ATTRIBUTE_EXPRESSION__ATTRIBUTE_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FogAdlModelPackage.Literals.ATTRIBUTE_EXPRESSION__ATTRIBUTE_NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNetworkClassExpressionAccess().getAttributeNameNetworkClassKeyword_0(), semanticObject.getAttributeName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     NetworkLinksType returns NetworkLinkType
	 *
	 * Constraint:
	 *     (name=ID tags+=Tag* (constraints+=Constraint | constraints+=networkClassConstraint)*)
	 * </pre>
	 */
	protected void sequence_NetworkLinksType(ISerializationContext context, NetworkLinkType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     NetworkPort returns NetworkPort
	 *
	 * Constraint:
	 *     (portName=STRING protocol=TransportProtocol portNumber=INT hostPort=INT)
	 * </pre>
	 */
	protected void sequence_NetworkPort(ISerializationContext context, NetworkPort semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FogAdlModelPackage.Literals.NETWORK_PORT__PORT_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FogAdlModelPackage.Literals.NETWORK_PORT__PORT_NAME));
			if (transientValues.isValueTransient(semanticObject, FogAdlModelPackage.Literals.NETWORK_PORT__PROTOCOL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FogAdlModelPackage.Literals.NETWORK_PORT__PROTOCOL));
			if (transientValues.isValueTransient(semanticObject, FogAdlModelPackage.Literals.NETWORK_PORT__PORT_NUMBER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FogAdlModelPackage.Literals.NETWORK_PORT__PORT_NUMBER));
			if (transientValues.isValueTransient(semanticObject, FogAdlModelPackage.Literals.NETWORK_PORT__HOST_PORT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FogAdlModelPackage.Literals.NETWORK_PORT__HOST_PORT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNetworkPortAccess().getPortNameSTRINGTerminalRuleCall_0_0(), semanticObject.getPortName());
		feeder.accept(grammarAccess.getNetworkPortAccess().getProtocolTransportProtocolEnumRuleCall_4_0(), semanticObject.getProtocol());
		feeder.accept(grammarAccess.getNetworkPortAccess().getPortNumberINTTerminalRuleCall_7_0(), semanticObject.getPortNumber());
		feeder.accept(grammarAccess.getNetworkPortAccess().getHostPortINTTerminalRuleCall_10_0(), semanticObject.getHostPort());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FogResource returns NetworkType
	 *     NetworkType returns NetworkType
	 *
	 * Constraint:
	 *     (name=ID? tags+=Tag* (constraints+=Constraint | constraints+=networkClassConstraint)*)
	 * </pre>
	 */
	protected void sequence_NetworkType(ISerializationContext context, NetworkType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FogResource returns PhysicalNodeSpecification
	 *     PhysicalNodeType returns PhysicalNodeSpecification
	 *
	 * Constraint:
	 *     (
	 *         name=EString? 
	 *         tags+=Tag* 
	 *         constraints+=CpuConstraint* 
	 *         constraints+=MemoryConsraint* 
	 *         constraints+=diskConstraint* 
	 *         constraints+=Constraint* 
	 *         downloadLink+=NetworkLinksType* 
	 *         uploadLink+=NetworkLinksType*
	 *     )
	 * </pre>
	 */
	protected void sequence_PhysicalNodeType(ISerializationContext context, PhysicalNodeSpecification semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FogResource returns PhysicalNode
	 *     PhysicalNode returns PhysicalNode
	 *
	 * Constraint:
	 *     (
	 *         name=ID? 
	 *         fogarea=[FogArea|ID] 
	 *         tags+=Tag* 
	 *         isInstanceOf=[PhysicalNodeSpecification|ID] 
	 *         hostedVirtualNodes+=[VirtualNode|ID]* 
	 *         attributes+=AttributeValueUnit*
	 *     )
	 * </pre>
	 */
	protected void sequence_PhysicalNode(ISerializationContext context, PhysicalNode semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     PortsConstraint returns Constraint
	 *
	 * Constraint:
	 *     (expression+=portsExpression expression+=MultiplicityExpression)
	 * </pre>
	 */
	protected void sequence_PortsConstraint(ISerializationContext context, Constraint semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ReplicasAttributeExpression returns AttributeExpression
	 *
	 * Constraint:
	 *     attributeName='replicas'
	 * </pre>
	 */
	protected void sequence_ReplicasAttributeExpression(ISerializationContext context, AttributeExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FogAdlModelPackage.Literals.ATTRIBUTE_EXPRESSION__ATTRIBUTE_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FogAdlModelPackage.Literals.ATTRIBUTE_EXPRESSION__ATTRIBUTE_NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getReplicasAttributeExpressionAccess().getAttributeNameReplicasKeyword_0(), semanticObject.getAttributeName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ReplicasConstraint returns Constraint
	 *
	 * Constraint:
	 *     (
	 *         expression+=ReplicasAttributeExpression 
	 *         (expression+=IntegerValueExpression | (operator=ComparaisonOperator expression+=IntegerValueExpression))
	 *     )
	 * </pre>
	 */
	protected void sequence_ReplicasConstraint(ISerializationContext context, Constraint semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     RuntimesAttributeExpression returns AttributeExpression
	 *
	 * Constraint:
	 *     attributeName='runtimes'
	 * </pre>
	 */
	protected void sequence_RuntimesAttributeExpression(ISerializationContext context, AttributeExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FogAdlModelPackage.Literals.ATTRIBUTE_EXPRESSION__ATTRIBUTE_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FogAdlModelPackage.Literals.ATTRIBUTE_EXPRESSION__ATTRIBUTE_NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRuntimesAttributeExpressionAccess().getAttributeNameRuntimesKeyword_0(), semanticObject.getAttributeName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     RuntimesConstraint returns Constraint
	 *
	 * Constraint:
	 *     (expression+=RuntimesAttributeExpression (expression+=CustomExpression | (operator=ComparaisonOperator expression+=CustomExpression)))
	 * </pre>
	 */
	protected void sequence_RuntimesConstraint(ISerializationContext context, Constraint semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FogResource returns ServiceType
	 *     SerivceType returns ServiceType
	 *
	 * Constraint:
	 *     (
	 *         name=ID? 
	 *         tags+=Tag* 
	 *         ((constraints+=PortsConstraint networkPorts+=NetworkPort*) | networkPorts+=NetworkPort+)? 
	 *         (implementedBy+=SoftwarePackage implementedBy+=SoftwarePackage*)? 
	 *         constraints+=Constraint*
	 *     )
	 * </pre>
	 */
	protected void sequence_SerivceType(ISerializationContext context, ServiceType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SoftwarePackage returns SoftwarePackage
	 *
	 * Constraint:
	 *     (name=ID installStartScript=EString constraints+=ReplicasConstraint*)
	 * </pre>
	 */
	protected void sequence_SoftwarePackage(ISerializationContext context, SoftwarePackage semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Tag returns Tag
	 *
	 * Constraint:
	 *     (key=ID value=ID)
	 * </pre>
	 */
	protected void sequence_Tag(ISerializationContext context, Tag semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FogAdlModelPackage.Literals.TAG__KEY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FogAdlModelPackage.Literals.TAG__KEY));
			if (transientValues.isValueTransient(semanticObject, FogAdlModelPackage.Literals.TAG__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FogAdlModelPackage.Literals.TAG__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTagAccess().getKeyIDTerminalRuleCall_0_0(), semanticObject.getKey());
		feeder.accept(grammarAccess.getTagAccess().getValueIDTerminalRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FogResource returns VirtualNodeSpecification
	 *     VirtualNodeType returns VirtualNodeSpecification
	 *
	 * Constraint:
	 *     (
	 *         name=EString? 
	 *         tags+=Tag* 
	 *         imageName=ID 
	 *         imageRegistry=ID 
	 *         replicas+=ReplicasConstraint* 
	 *         constraints+=CpuConstraint* 
	 *         constraints+=MemoryConsraint* 
	 *         constraints+=diskConstraint* 
	 *         constraints+=Constraint* 
	 *         hostingNode=VirtualNodeType? 
	 *         downloadLink+=NetworkLinksType* 
	 *         uploadLink+=NetworkLinksType*
	 *     )
	 * </pre>
	 */
	protected void sequence_VirtualNodeType(ISerializationContext context, VirtualNodeSpecification semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FogResource returns VirtualNode
	 *     VirtualNode returns VirtualNode
	 *
	 * Constraint:
	 *     (
	 *         name=ID? 
	 *         tags+=Tag* 
	 *         isInstanceOf=[VirtualNodeSpecification|ID] 
	 *         hostingNode=[Node|ID] 
	 *         hostedVirtualNodes+=[VirtualNode|ID]* 
	 *         attributes+=AttributeValueUnit*
	 *     )
	 * </pre>
	 */
	protected void sequence_VirtualNode(ISerializationContext context, VirtualNode semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     bandwidthExpression returns AttributeExpression
	 *
	 * Constraint:
	 *     attributeName='bandwidth'
	 * </pre>
	 */
	protected void sequence_bandwidthExpression(ISerializationContext context, AttributeExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FogAdlModelPackage.Literals.ATTRIBUTE_EXPRESSION__ATTRIBUTE_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FogAdlModelPackage.Literals.ATTRIBUTE_EXPRESSION__ATTRIBUTE_NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBandwidthExpressionAccess().getAttributeNameBandwidthKeyword_0(), semanticObject.getAttributeName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     diskConstraint returns Constraint
	 *
	 * Constraint:
	 *     (expression+=DiskAttributeExpression (expression+=IntegerValueExpression | (operator=ComparaisonOperator expression+=IntegerValueExpression)))
	 * </pre>
	 */
	protected void sequence_diskConstraint(ISerializationContext context, Constraint semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FogResource returns FogArea
	 *     fogArea returns FogArea
	 *
	 * Constraint:
	 *     (name=EString fogsystem=[FogSystem|ID])
	 * </pre>
	 */
	protected void sequence_fogArea(ISerializationContext context, FogArea semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FogAdlModelPackage.Literals.FOG_RESOURCE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FogAdlModelPackage.Literals.FOG_RESOURCE__NAME));
			if (transientValues.isValueTransient(semanticObject, FogAdlModelPackage.Literals.FOG_AREA__FOGSYSTEM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FogAdlModelPackage.Literals.FOG_AREA__FOGSYSTEM));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFogAreaAccess().getNameEStringParserRuleCall_2_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getFogAreaAccess().getFogsystemFogSystemIDTerminalRuleCall_5_0_1(), semanticObject.eGet(FogAdlModelPackage.Literals.FOG_AREA__FOGSYSTEM, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FogResource returns FogSystem
	 *     fogSystem returns FogSystem
	 *
	 * Constraint:
	 *     name=EString
	 * </pre>
	 */
	protected void sequence_fogSystem(ISerializationContext context, FogSystem semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FogAdlModelPackage.Literals.FOG_RESOURCE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FogAdlModelPackage.Literals.FOG_RESOURCE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFogSystemAccess().getNameEStringParserRuleCall_2_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ipRangeConstraint returns Constraint
	 *
	 * Constraint:
	 *     (expression+=ipRangeExpression expression+=rangeExpression)
	 * </pre>
	 */
	protected void sequence_ipRangeConstraint(ISerializationContext context, Constraint semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ipRangeExpression returns AttributeExpression
	 *
	 * Constraint:
	 *     attributeName='ipRange'
	 * </pre>
	 */
	protected void sequence_ipRangeExpression(ISerializationContext context, AttributeExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FogAdlModelPackage.Literals.ATTRIBUTE_EXPRESSION__ATTRIBUTE_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FogAdlModelPackage.Literals.ATTRIBUTE_EXPRESSION__ATTRIBUTE_NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIpRangeExpressionAccess().getAttributeNameIpRangeKeyword_0(), semanticObject.getAttributeName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     networkClassConstraint returns Constraint
	 *
	 * Constraint:
	 *     ((expression+=NetworkClassExpression expression+=NetworkClassEnumExpression) | (operator=ComparaisonOperator expression+=IntegerValueExpression))
	 * </pre>
	 */
	protected void sequence_networkClassConstraint(ISerializationContext context, Constraint semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     portsExpression returns AttributeExpression
	 *
	 * Constraint:
	 *     attributeName='networkPort'
	 * </pre>
	 */
	protected void sequence_portsExpression(ISerializationContext context, AttributeExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FogAdlModelPackage.Literals.ATTRIBUTE_EXPRESSION__ATTRIBUTE_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FogAdlModelPackage.Literals.ATTRIBUTE_EXPRESSION__ATTRIBUTE_NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPortsExpressionAccess().getAttributeNameNetworkPortKeyword_0(), semanticObject.getAttributeName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     rangeExpression returns CustomExpression
	 *
	 * Constraint:
	 *     expression='['
	 * </pre>
	 */
	protected void sequence_rangeExpression(ISerializationContext context, CustomExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FogAdlModelPackage.Literals.CUSTOM_EXPRESSION__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FogAdlModelPackage.Literals.CUSTOM_EXPRESSION__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRangeExpressionAccess().getExpressionLeftSquareBracketKeyword_1_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
}
