/*
 * generated by Xtext 2.25.0
 */
package fr.imta.semafor.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import com.google.inject.Inject
import org.eclipse.xtext.naming.IQualifiedNameProvider
import org.eclipse.xtext.resource.IResourceServiceProvider.Registry
import ConstrainedProblem.*
import ConstrainedProblem.ConstrainedVariable
import javax.security.auth.login.Configuration.Parameters
import ConstrainedProblem.ConstrainedObject
import org.eclipse.jdt.internal.core.builder.ProblemFactory
import ConstrainedProblem.ConstrainedProblemPackage

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 * 
 * This Class generates a Choco problem from the Fog Model consisting in the sum of yml files in the project under edition in the Client Eclipse
 * This is done in two steps : 
 * First an abstract technology agnostic constrainedProblem is generated (reconfigurationProblem)
 * Second, this agnostic model is transformed to Choco code
 * 
 */
class FogDslGenerator extends AbstractGenerator {
	String DOT = '.'
	String FORWARD_SLASH = '/'
	String JAVA_EXTENTION = 'java'
	String XML_EXTENTION = 'xml'
	String CHOCO_FILE_NAME = "chocoGeneratedProblem"
	
	Problem reconfigurationProblem
	FogAdlModel2constraintProblemTransformer transformer
	
	@Inject extension IQualifiedNameProvider
	
	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
				
//		transformer = new FogAdlModel2constraintProblemTransformer(resource);
		
//		reconfigurationProblem = transformer.generateConstrainedProblem();
		
		reconfigurationProblem = FogAdlModel2constraintProblemTransformer.generateSampleConstrainedProblem();
		
		
		fsa.generateFile(CHOCO_FILE_NAME + DOT + JAVA_EXTENTION, this.generateHeader)
		


		for (ConstrainedProblem.Constraint cstrnt : reconfigurationProblem.constraints) {
			cstrnt.compile
		}
	    System.out.println("end of generation")    
}
	
	def generateHeader() {
			'''
			//Add the imports here
			«FOR variable : reconfigurationProblem.constrainedVariables»
			«variable.declare»
			«ENDFOR»
			«FOR variable : reconfigurationProblem.expressions.filter(IndirectVariableExpre)»
			«variable.declare»
			«ENDFOR»
			«FOR variable : reconfigurationProblem.expressions.filter(IndirectVariableExpre)»
			«variable.createEqualityConstraints»
			«ENDFOR»
			«FOR cstrnt : reconfigurationProblem.constraints»
			«cstrnt.compile»
			«ENDFOR»
			'''
	}

	def createEqualityConstraints(IndirectVariableExpre expre){
		// Example (VM: host: cpu) > 3
			for (Integer i : (expre.constrainedObject.schema.possibleValues)){
				createConstraint("if", expre.constrainedObject.getChocoVariableName, "equals", i, "then", expre.generateTargetIndirectVariableExpression, "equals", chocoVariableName(reconfigurationProblem.constrainedobjects.get(i), expre.variableName))
			}
		}
		
	def createConstraint(String _if, CharSequence sequence, String _equals, Integer integer, String _then, CharSequence sequence2, String __equals, CharSequence sequence3) {
		'''
		«_if + " " + sequence + " " + _equals + " " + integer + " " + _then + " " + sequence2 + " " + __equals + " " + sequence3»
		'''
	}
		
	def chocoVariableName(ConstrainedObject object, String string) {
		'''«object.schema.type + "-" + object.schema.name + "_" + string»'''
	}
	
	def generateTargetDirectVariableExpression(DirectVariableExpre variable){
		// Returns the name of the IntVar variable corresponding to "variable".
		// Remember that, the generated name of the IntVar variable (see compile(variable) in this class) consists in the ConstrainedObject + the name of this "variable"
		'''
		«variable.constrainedVariable.getChocoVariableName»
		'''
	}
	
	def generateTargetIndirectVariableExpression(IndirectVariableExpre variable){
		//Here, I create an extra variable for the sake of the constraint.
		// Later, I will create another constraint to make sure this extra variable is equal to the actual variable of the object under constraint (the host for instance)
		'''
		«variable.constrainedObject.getChocoVariableName + "_" + variable.variableName»
		'''
	}
	
	def generateTargetVariableExpression(IntValueExpression value){
		'''
		«value.value»
		'''
	}
	
	def generateComplexExpression(ComplexExpression expression){
		'''
		«expression.expressions.get(0).compile()»
		«expression.arithmeticOperator»
		«expression.expressions.get(1).compile()»
		'''
	}
		
	def compile(ConstrainedProblem.Expression expression){
		switch (expression.eClass.classifierID) {
			case ConstrainedProblemPackage.INDIRECT_VARIABLE_EXPRE: (expression as IndirectVariableExpre).generateTargetIndirectVariableExpression
			case ConstrainedProblemPackage.DIRECT_VARIABLE_EXPRE: (expression as DirectVariableExpre).generateTargetDirectVariableExpression
			case ConstrainedProblemPackage.INT_VALUE_EXPRESSION: (expression as IntValueExpression).generateTargetVariableExpression
			case ConstrainedProblemPackage.COMPLEX_EXPRESSION: (expression as ComplexExpression).generateComplexExpression		
		}
	}
		
	def declareIndirectVariables() {

		for (IndirectVariableExpre variable : reconfigurationProblem.expressions.filter(IndirectVariableExpre)) {
			variable.declare
		}

	}		
	
	def declare(ConstrainedProblem.IndirectVariableExpre expression){
		'''
		//créer une IntVar avec «expression.variableName» No matter what its possible values are since its is equal to some directVariables
		IntVar «this.generateTargetIndirectVariableExpression(expression)» = new IntVar();
		'''
	}
	
	def compile(ConstrainedProblem.Constraint cstrnt){
		'''
		//Create a Choco constraint with 
		// right hand expression : «cstrnt.expressions.get(1).compile»
		// comparaison operator : «cstrnt.comparaisonOperator»
		// left hand expression : «cstrnt.expressions.get(0).compile»
		'''
		
		

	}
	
	
	def declare(ConstrainedVariable variable){
		'''
		//créer une IntVar avec «variable.schema.name»
		IntVar «variable.getChocoVariableName» = new IntVar();
		// etc.
		// Il ne sera pas nécessaire d'Ajouter IntVar au dictionnaire des variable car son nom est identifiant
		
		'''
	}
	
	def getChocoVariableName(ConstrainedVariable variable){
		'''«chocoVariableName(variable.constrainedobject, variable.schema.name)»'''
	}
	
}
